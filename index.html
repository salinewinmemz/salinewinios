
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Screen Tunneling Effect</title>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: auto;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: white;
    }

    /* The page content — replace or keep your existing DOM here */
    .page {
      padding: 36px;
      max-width: 900px;
      margin: 0 auto;
      line-height: 1.5;
    }
    h1 { font-size: 34px; margin-bottom: 0.25rem; }
    p { color: #ddd; }

    /* Fullscreen WebGL overlay for the tunneling effect */
    canvas#gl {
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      pointer-events: none; /* allow interacting with page underneath */
      display: block;
    }

    /* small unobtrusive hint */
    #hint {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 10000;
      font-size: 13px;
      color: rgba(255,255,255,0.9);
      background: rgba(0,0,0,0.25);
      padding: 8px 10px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
      user-select:none;
      pointer-events: auto;
    }
  </style>
</head>
<body>

  <div class="page" id="page">
    <h1>Example Page Content</h1>
    <p>This page demonstrates a "screen tunneling" post-process: the current page is captured once and the capture is warped into a full-screen tunneling animation on top of the page. Interactions still work because the effect canvas uses pointer-events: none.</p>
    <p>Double-click (or press <kbd>R</kbd>) to recapture the current page and update the tunneling source.</p>

    <h2>Notes</h2>
    <p>To apply this to your real site, keep your page content as usual — the script captures the visible DOM and uses that image as the texture for the tunnel shader.</p>

    <p>Scroll around and then double-click to capture the current viewport.</p>

    <p style="margin-top:40vh">End of demo content — scroll up to see more before recapturing.</p>
  </div>

  <canvas id="gl"></canvas>
  <div id="hint">Double-click or press R to recapture</div>

  <!-- html2canvas: used to take a snapshot of the page DOM for the shader texture -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
  // SCREEN TUNNELING: capture the current page into a texture and animate a tunnel warp of that image
  (function () {
    const canvas = document.getElementById('gl');
    const hint = document.getElementById('hint');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      hint.textContent = 'WebGL not supported';
      return;
    }

    // Vertex shader: full-screen quad
    const vs = `
      attribute vec2 a_pos;
      varying vec2 v_uv;
      void main() {
        v_uv = a_pos * 0.5 + 0.5;
        gl_Position = vec4(a_pos, 0.0, 1.0);
      }`;

    // Fragment shader: sample the captured page texture and apply a tunneling/polar warp
    const fs = `
      precision mediump float;
      varying vec2 v_uv;
      uniform sampler2D u_tex;
      uniform vec2 u_res;
      uniform float u_time;
      uniform vec2 u_mouse; // normalized [-1..1]
      const float PI = 3.141592653589793;

      // simple palette tweak for glow
      vec3 tonemap(vec3 c) {
        return pow(c, vec3(0.9));
      }

      void main() {
        // coordinates centered and aspect-corrected
        vec2 uv = v_uv;
        vec2 p = uv - 0.5;
        p.x *= u_res.x / u_res.y;

        // polar coordinates
        float r = length(p);
        float a = atan(p.y, p.x);

        // steering from mouse / touch (small)
        float steer = u_mouse.x * 0.6;
        a += steer;

        // create dynamic depth/distortion
        float t = u_time * 0.6;
        // Depth mapping: make outer radius map to near texture v, inner radius to far
        // Use a log-like mapping for stronger tunnel feel
        float depth = 1.0 / max(r + 0.001, 0.001);
        // animated shifting
        float z = fract(depth * 0.06 - t * 0.08);

        // rotate samples based on angle and time to create swirling
        float swirl = 0.6 * sin(depth * 0.8 + t * 2.0 + a * 1.5);
        a += swirl;

        // Convert polar back to texture uv coordinates.
        // Map angle to horizontal coordinate and depth to vertical coordinate
        float u = (a / (2.0 * PI)) + 0.5 + 0.02 * sin(depth*5.0 + t*3.0);
        float v = 1.0 - z;

        // Add subtle ripple based on radius
        u += 0.01 * sin(12.0 * r - t*6.0 + a*4.0);

        vec3 col = texture2D(u_tex, vec2(u, v)).rgb;

        // add some rim glow / brightness for inner area
        float rim = smoothstep(0.45, 0.0, r);
        col += vec3(0.18, 0.08, 0.03) * rim * (0.6 + 0.6*sin(t*2.0 + r*40.0));

        // vignette / falloff
        col *= 1.0 / (1.0 + r*r*3.5);

        col = tonemap(col);
        gl_FragColor = vec4(col, 1.0);
      }`;

    function compile(src, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        throw new Error('Shader compile failed');
      }
      return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, compile(vs, gl.VERTEX_SHADER));
    gl.attachShader(prog, compile(fs, gl.FRAGMENT_SHADER));
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      throw new Error('Program link failed');
    }
    gl.useProgram(prog);

    // fullscreen quad
    const quad = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
    const a_pos = gl.getAttribLocation(prog, 'a_pos');
    gl.enableVertexAttribArray(a_pos);
    gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

    // uniforms
    const u_time = gl.getUniformLocation(prog, 'u_time');
    const u_res = gl.getUniformLocation(prog, 'u_res');
    const u_mouse = gl.getUniformLocation(prog, 'u_mouse');
    const u_tex = gl.getUniformLocation(prog, 'u_tex');

    // texture setup
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // set sensible defaults so we can draw even before upload
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    // Resize handling
    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 1.5); // cap DPR for mobile memory
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize, {passive: true});
    resize();

    // keep normalized mouse in [-1..1]
    let mouse = [0,0];
    function onMove(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || (e.touches && e.touches[0].clientX) || 0) - rect.left;
      const y = (e.clientY || (e.touches && e.touches[0].clientY) || 0) - rect.top;
      const nx = (x / rect.width) * 2 - 1;
      const ny = ( (rect.height - y) / rect.height) * 2 - 1;
      mouse[0] = nx;
      mouse[1] = ny;
    }
    window.addEventListener('mousemove', onMove, {passive:true});
    window.addEventListener('touchmove', onMove, {passive:true});

    // capture the visible page using html2canvas and upload to WebGL texture
    let lastCaptureSize = {w:0, h:0};
    async function captureOnce() {
      // hide our overlay canvas & hint so the capture ignores them
      const oldDisplay = canvas.style.display;
      const oldHint = hint.style.display;
      canvas.style.display = 'none';
      hint.style.display = 'none';

      // cap the target size to avoid huge textures (better for mobile)
      const maxDim = 1024; // max texture dimension
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const scale = Math.min(1, maxDim / Math.max(vw, vh));

      try {
        const snap = await html2canvas(document.body, {
          useCORS: true,
          logging: false,
          windowWidth: document.documentElement.scrollWidth,
          windowHeight: document.documentElement.scrollHeight,
          scale: scale
        });

        // If the snapshot size changed, update lastCaptureSize
        lastCaptureSize.w = snap.width;
        lastCaptureSize.h = snap.height;

        gl.bindTexture(gl.TEXTURE_2D, texture);
        // upload the captured canvas as WebGL texture
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        try {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, snap);
        } catch (err) {
          // some drivers require the image to be power-of-two or need special handling — fallback: draw to an intermediate canvas
          const tmp = document.createElement('canvas');
          tmp.width = snap.width;
          tmp.height = snap.height;
          const ctx = tmp.getContext('2d');
          ctx.drawImage(snap, 0, 0);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tmp);
        }

        // generate mipmaps if texture is POT; otherwise keep linear
        const isPOT = ( (snap.width & (snap.width - 1)) === 0 ) && ( (snap.height & (snap.height - 1)) === 0 );
        if (isPOT) {
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }

      } catch (e) {
        console.error('Capture failed', e);
      } finally {
        // show overlay again
        canvas.style.display = oldDisplay;
        hint.style.display = oldHint;
      }
    }

    // initial capture
    captureOnce();

    // allow user to recapture with double click or R key
    window.addEventListener('dblclick', (e) => {
      captureOnce();
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') captureOnce();
    });

    // animation loop
    let start = performance.now();
    function draw() {
      const t = (performance.now() - start) * 0.001;

      gl.clearColor(0,0,0,1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(prog);

      gl.uniform1f(u_time, t);
      gl.uniform2f(u_res, canvas.width, canvas.height);
      gl.uniform2f(u_mouse, mouse[0], mouse[1]);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(u_tex, 0);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // helpful: if user scrolls or resizes a lot, they may want to recapture
    // (no automatic recapture — manual via dblclick or R)
  })();
  </script>

</body>
</html>
