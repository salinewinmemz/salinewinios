
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tunnel Effect</title>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: white;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .ui {
      position: absolute;
      left: 16px;
      top: 16px;
      z-index: 3;
      user-select: none;
      pointer-events: none;
      background: linear-gradient(90deg, rgba(0,0,0,0.25), rgba(0,0,0,0.08));
      padding: 8px 12px;
      border-radius: 8px;
      backdrop-filter: blur(6px);
      font-size: 13px;
      pointer-events: auto;
    }
    .controls {
      margin-top: 8px;
      display:flex;
      gap:8px;
      align-items:center;
      pointer-events:auto;
    }
    .controls input[type="range"] { width: 120px; }
    .hint { opacity: 0.8; font-size: 12px; margin-top:6px; }
    a { color: #8fd3ff; text-decoration: none; }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>

  <div class="ui" id="ui">
    <div><strong>Tunnel Shader</strong></div>
    <div class="controls">
      <label style="font-size:12px">Speed
        <input id="speed" type="range" min="0" max="4" step="0.01" value="1.0">
      </label>
      <label style="font-size:12px">Warp
        <input id="warp" type="range" min="0" max="6" step="0.01" value="1.8">
      </label>
    </div>
    <div class="hint">Move mouse to steer â€¢ Resize window is supported</div>
  </div>

  <script>
  // Simple WebGL shader tunnel effect
  const canvas = document.getElementById('gl');
  const ui = document.getElementById('ui');
  const speedInput = document.getElementById('speed');
  const warpInput = document.getElementById('warp');

  const gl = canvas.getContext('webgl');
  if (!gl) {
    document.body.innerHTML = '<div style="color:white;padding:20px">WebGL not supported.</div>';
    throw new Error('WebGL not supported');
  }

  const vertexSrc = `
  attribute vec2 a_position;
  varying vec2 v_uv;
  void main() {
    v_uv = a_position * 0.5 + 0.5;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }`;

  const fragmentSrc = `
  precision highp float;
  uniform vec2 iResolution;
  uniform float iTime;
  uniform vec2 iMouse;
  uniform float u_speed;
  uniform float u_warp;
  varying vec2 v_uv;

  // A compact tunnel shader using polar coords + layering
  void main() {
    vec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;

    // mouse influence: steer angle and offset
    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;
    mouse.x *= iResolution.x / iResolution.y;

    float time = iTime * u_speed;

    // polar coords
    float angle = atan(uv.y, uv.x);
    float radius = length(uv);

    // add steering
    angle += mouse.x * 1.5;
    uv += mouse * 0.35;

    // tunnel coordinate transform (logarithmic depth illusion)
    float depth = 1.0 / max(radius, 0.001);
    float z = depth * 0.5 + time;

    // radial bands and rings
    float rings = sin((radius * u_warp * 12.0) - time * 6.0 + angle * 4.0);
    float bands = fract((z * 0.5) + sin(angle*3.0 + time)*0.1);

    // combine layers for color
    float stripe = smoothstep(0.4, 0.5, rings * 0.5 + 0.5);
    float innerGlow = pow(clamp(1.0 - radius * 1.8, 0.0, 1.0), 2.0);

    vec3 base = mix(vec3(0.02,0.06,0.15), vec3(0.0,0.2,0.5), bands);
    vec3 accent = vec3(1.0, 0.6, 0.2) * stripe * (0.5 + 0.5*sin(time*2.0 + radius*40.0));
    vec3 color = base + accent * innerGlow;

    // vignetting and falloff
    color *= 1.0 / (1.0 + radius*radius*4.0);

    // final tonemapping
    color = pow(color, vec3(0.9));
    gl_FragColor = vec4(color, 1.0);
  }`;

  function compileShader(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile error');
    }
    return s;
  }

  const vShader = compileShader(vertexSrc, gl.VERTEX_SHADER);
  const fShader = compileShader(fragmentSrc, gl.FRAGMENT_SHADER);

  const program = gl.createProgram();
  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error('Program link error');
  }

  gl.useProgram(program);

  // Fullscreen quad
  const quad = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1,
  ]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

  const posLoc = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const iResolutionLoc = gl.getUniformLocation(program, 'iResolution');
  const iTimeLoc = gl.getUniformLocation(program, 'iTime');
  const iMouseLoc = gl.getUniformLocation(program, 'iMouse');
  const uSpeedLoc = gl.getUniformLocation(program, 'u_speed');
  const uWarpLoc = gl.getUniformLocation(program, 'u_warp');

  // state
  let start = performance.now();
  let mousePos = [0, 0];
  let isPointerDown = false;

  function resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Mouse/touch handlers
  function setMouse(e) {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX)) - rect.left;
    const y = ((e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY)) - rect.top;
    mousePos[0] = x * (canvas.width / rect.width);
    mousePos[1] = (rect.height - y) * (canvas.height / rect.height); // flip y for shader
  }
  window.addEventListener('mousemove', (e) => { setMouse(e); }, {passive:true});
  window.addEventListener('touchmove', (e) => { setMouse(e); e.preventDefault(); }, {passive:false});

  // animation
  function render() {
    const now = performance.now();
    const t = (now - start) * 0.001;

    gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
    gl.uniform1f(iTimeLoc, t);
    gl.uniform2f(iMouseLoc, mousePos[0] || 0.0, mousePos[1] || 0.0);
    gl.uniform1f(uSpeedLoc, parseFloat(speedInput.value));
    gl.uniform1f(uWarpLoc, parseFloat(warpInput.value));

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // Small accessibility: hide UI when clicking canvas and bring back on move
  canvas.addEventListener('click', () => {
    if (ui.style.display === 'none') ui.style.display = '';
    else ui.style.display = 'none';
  });

  // Initial mouse position center
  mousePos[0] = canvas.width * 0.5;
  mousePos[1] = canvas.height * 0.5;
  </script>
</body>
</html>
